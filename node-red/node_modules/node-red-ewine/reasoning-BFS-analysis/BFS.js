/**
 * Copyright 2016 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 **/

module.exports = function(RED)
{
	"use strict";
	var fs = require("fs-extra");
	var spawn = require('child_process').spawn;

	function BFS(n)
	{
		RED.nodes.createNode(this,n);
		this.outCol_Idx = parseInt(n.outCol_Idx);
		this.performLog = (n.performLog === true ? 1 : 0);
		this.nTerms 	= parseInt(n.nTerms);
		this.nModels 	= parseInt(n.nModels);
		this.nNewModels = parseInt(n.nNewModels);
		this.response_path = n.response_path;
		this.analysis_path = n.analysis_path;

		var node = this;

		this.on("input", function(msg)
		{
			node.status({fill:"green", shape:"dot", text:"executing"});

			// sample index
			var sample_Idx = msg.sample_Idx;

			// Exploration phase
			if(msg.topic == "exploration")
			{
				msg = {};
				msg.sample_Idx = sample_Idx + 1;

				node.status({});
				node.send([msg, null, null]);
			}
			// Exploitation phase. Analyze the results of the Locating Array
			else if(msg.topic == "exploitation")
			{
				// Retrieve Constructed Locating Array and create sampleSet data
				var response_str   = fs.readFileSync(node.response_path, {'encoding': 'utf8'});
				var response_array = response_str.trim().split("\n");

				// response header string
				var response_hdr_str   = response_array[0];
				var response_hdr_array = response_hdr_str.split(";");

				// Lower bound, upper bound and steps
				var lb    = response_hdr_array[0].split("[")[1].trim();
				var ub    = response_hdr_array[1].trim();
				var steps = response_hdr_array[2].split("]")[0].trim();

				var lb_array    = lb.split(",");
				var ub_array    = ub.split(",");
				var steps_array = steps.split(",");

				// Size of configuration parameters
				if(lb_array.length != ub_array.length || ub_array.length != steps_array.length)
				{
					var msg = {payload: "Unequal number of configuration parameters specified in response header string!"};

					node.status({fill:"red", shape:"dot", text:"Error"});
					node.send([null, null, msg]);
				}
				var par_size = lb_array.length;

				// Store specified response column into temporary file
				response_str = (response_array.length - 1) + "\nResponse\n";
				for(var i = 1; i < response_array.length; i++)
					response_str = response_str + response_array[i].split("\t")[par_size + node.outCol_Idx] + "\n";
				if(fs.existsSync("/tmp/responses") === false)
					fs.mkdirSync("/tmp/responses");
				fs.writeFileSync("/tmp/responses/response.tsv", response_str);

				// Start Breadth First Search (BFS) analysis
				var arg = "/tmp/LA_fixed.tsv /tmp/Factors.tsv analysis /tmp/responses Response " + node.performLog + " " + node.nTerms + " " + node.nModels + " " + node.nNewModels;
				arg = arg.match(/(?:[^\s"]+|"[^"]*")+/g);

				// Start BFS
				node.child = spawn("Search", arg);

				// BFS sends error data
				var analysis_str = "";
				node.child.stdout.on('data', function (data)
				{
					analysis_str = analysis_str + data.toString();
				});

				// Node has finished BFS analysis
				node.child.on('close', function (code)
				{
					node.child = null;
					fs.writeFileSync(node.analysis_path, analysis_str);

					var msg = {filename: node.analysis_path};

					node.status({});
					node.send([null, msg, null]);
				});

				// BFS sends error data
				node.child.stderr.on('data', function (data)
				{
					var msg = {payload: data.toString()};

					node.status({fill:"red", shape:"dot", text:"Error"});
					node.send([null, null, msg]);
				});

				// BFS execution error
				node.child.on('error', function (err)
				{
					if(err.errno === "ENOENT")
						node.warn('BFS: command not found');
					else if(err.errno === "EACCES")
						node.warn('BFS: command not executable');
					else
						node.log('BFS: error: ' + err);
				});
			}
		});
	}
	RED.nodes.registerType("BFS",BFS);
}
