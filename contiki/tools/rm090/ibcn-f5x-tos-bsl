#!/usr/bin/env python2
# -*- coding: utf-8 -*-
# Serial Bootstrap Loader software for the MSP430F5xxx embedded proccessor.
#
# (C) 2010 Bart Jooris <Bart.Jooris@intec.ugent.be>
# based on the 'tos-bsl' tinyos-2.1 application and slau319a.pdf from Texas Instruments, Inc.,

import sys, time, string, cStringIO, struct
sys.path.append("/usr/lib/tinyos")
import serial, crcmod

VERSION = string.split("Revision: 0.02 ")[1]

DEBUG = 0                                       #enable debug messages by default


#cpu types for "change baudrate"
#use strings as ID so that they can be used in outputs too
F5x                     = "F5x family"

#known device list
deviceids = {
    0xf547: F5x,
}

class BSLException(Exception):
	pass

class LowLevel:
	"lowlevel communication"
	#Constants

	BSL_PI_HEADER              		= 0x80
	BSL_CMD_RXBLK           		= 0x10 #Receive  block from boot loader   Transmit block to boot loader
	BSL_CMD_RXBLKF          		= 0x1B #Receive  block from boot loader Fast
	BSL_CMD_RXPASSWORD				= 0x11
	BSL_CMD_ERASESEG				= 0x12
	BSL_CMD_U_LOCKINFO				= 0x13
	BSL_CMD_MASSERASE				= 0x15
	BSL_CMD_CRCCHECK				= 0x16
	BSL_CMD_LOADPC					= 0x17
	BSL_CMD_TXBLK           		= 0x18 #Transmit block to boot loader
	BSL_CMD_TXBSLVERSION			= 0x19
	BSL_CMD_TXBUFFERSIZE      	 	= 0x1A
	BSL_CMD_CHANGEBAUDRATE     		= 0x52

	BSL_ERR_MSG_ACK					= 0x00
	BSL_ERR_MSG_CRC 				= 0x52
	BSL_CORE_MSG_ACK				= 0x00
	
	BSL_CORE_RESP_DATA				= 0x3A
	BSL_CORE_RESP_MSG				= 0x3B
	
	BSL_ERR_MSG = {
		0x00:"ACK",
		0x51:"Header incorrect. The packet did not begin with the required 0x80 value.",
		0x52:"Checksum incorrect. The packet did not have the correct checksum value.",
		0x53:"Packet size zero. The size for the BSL core command was given as 0.",
		0x54:"Packet size exceeds buffer. The packet size given is too big for the RX buffer.",
		0x55:"Unknown error",
		0x55:"Unknown baud rate. The supplied data for baud rate change is not a known value.",
	}

	BSL_CORE_MSG = {
		0x00:"Operation Successful",
		0x01:"Flash Write Check Failed. After programming, a CRC is run on the programmed data. If the CRC does not match the expected result, this error is returned.",
		0x02:"Flash Fail Bit Set. An operation set the FAIL bit in the flash controller (see the MSP430x5xx User's Guide (SLAU208) for more details on the flash fail bit).",
		0x03:"Voltage Change During Program. The VPE was set during the requested write operation (see the MSP430x5xx User's Guide (SLAU208) for more details on the VPE bit).",
		0x04:"BSL Locked. The correct password has not yet been supplied to unlock the BSL.",
		0x05:"BSL Password Error. An incorrect password was supplied to the BSL when attempting an unlock.",
		0x06:"Byte Write Forbidden. This error is returned when a byte write is attempted in a flash area.",
		0x07:"Unknown Command. The command given to the BSL was not recognized.",
		0x08:"Packet Length Exceeds Buffer Size. The supplied packet length value is too large to be held in the BSL receive buffer.",
	}
	
    #Upper limit of address range that might be modified by
    #"BSL checksum bug".
	BSL_CRITICAL_ADDR				= 0x0A00


	DEFAULT_TIMEOUT         =   1
	DEFAULT_PROLONG         =  10
	MAX_FRAME_SIZE          = 256
	MAX_DATA_BYTES          = 250
	MAX_DATA_WORDS          = 125

	MAX_FRAME_COUNT         = 16

	#table with values from slau319a.pdf
	bauratetable = {
		F5x: {
			9600:0x02,
			57600:0x05
		},
	}

	def __init__(self, aTimeout = None, aProlongFactor = None):
		"""init bsl object, don't connect yet"""
		if aTimeout is None:
			self.timeout = self.DEFAULT_TIMEOUT
		else:
			self.timeout = aTimeout
		if aProlongFactor is None:
			self.prolongFactor = self.DEFAULT_PROLONG
		else:
			self.prolongFactor = aProlongFactor

		#flags for inverted use of control pins
		#used for some hardware
		self.invertRST = 1
		self.invertTEST = 0
		self.swapRSTTEST = 1
		self.retr = 0	#default: no retransmissions on crc error
		self.retrcnt = 0
		self.maxRetr = 10
		self.erasecnt = 0
		self.maxErasecnt = 5 #retry mass erase up to 5 times (can fail because of busy serialport)

		self.BSLMemAccessWarning = 0                #Default: no warning.
		self.slowmode = 0

	def comInit(self, port):
		"""Tries to open the serial port given and
		initialises the port and variables.
		The timeout and the number of allowed errors is multiplied by
		'aProlongFactor' after transmission of a command to give
		plenty of time to the micro controller to finish the command.
		Returns zero if the function is successful."""
		if DEBUG > 1: sys.stderr.write("* comInit()\n")
		self.seqNo = 0
		self.reqNo = 0
		self.rxPtr = 0
		self.txPtr = 0
		# Startup-Baudrate: 9600,8,E,1, 1s timeout
		self.serialport = serial.Serial(
			port,
			9600,
			parity = serial.PARITY_NONE,
			timeout = self.timeout
		)
		if DEBUG: sys.stderr.write("using serial port %r\n" % self.serialport.portstr)
		self.SetTESTpin(0)  #TEST pin: GND
		self.SetTESTpin(1)  #TEST pin: Vcc
		self.SetRSTpin(1)       #RST  pin: GND
		#time.sleep(0.005)       #give MSP430's oscillator time to stabilize
		self.serialport.flushInput()
		self.serialport.flushOutput()

	def comDone(self):
		"""Closes the used serial port.
		This function must be called at the end of a program,
		otherwise the serial port might not be released and can not be
		used in other programs.
		Returns zero if the function is successful."""
		if DEBUG > 1: sys.stderr.write("* comDone()\n")
		self.SetTESTpin(0)  #TEST pin: Vcc
		self.SetTESTpin(1)  #TEST pin: GND
		self.SetTESTpin(0)  #TEST pin: Vcc
		self.SetTESTpin(1)  #TEST pin: GND
		self.SetRSTpin(0)
		self.SetRSTpin(1)
		time.sleep(0.001)       #give MSP430's oscillator time to stabilize
		self.serialport.close()

	def comRxFrame(self):
		if DEBUG > 1: sys.stderr.write("* comRxFrame()\n")
		
		if DEBUG > 3: sys.stderr.write("  comRxFrame() PI header...\n")
		rxPiHeader = self.serialport.read(1)
		if len(rxPiHeader) != 1: raise BSLException("Timeout PiHeader")
		if ord(rxPiHeader) != self.BSL_PI_HEADER: raise BSLException("Bad Header")

		if DEBUG > 3: sys.stderr.write("  comRxFrame() PI Length...\n")
		rxPiLength = self.serialport.read(2)
		if len(rxPiLength) != 2: raise BSLException("Timeout rxPiLength")

		if DEBUG > 3: sys.stderr.write("  comRxFrame() bsl core cmd...\n")
		bslCoreRespLength = struct.unpack('<H',rxPiLength)[0]
		rxBslCoreCmd = self.serialport.read(bslCoreRespLength);
		if len(rxBslCoreCmd) != bslCoreRespLength: raise BSLException("Timeout bslCoreCmd")
		crc32_func = crcmod.predefined.mkCrcFun('crc-ccitt-false')
		checksum = crc32_func(rxBslCoreCmd)
		for c in rxBslCoreCmd[1:]:
			if DEBUG > 3: sys.stderr.write(" %02x" % ord(c))
		if DEBUG > 3: sys.stderr.write(" \n")
		
		if DEBUG > 3: sys.stderr.write("  comRxFrame() pi crc...\n")
		piFooterCrc = self.serialport.read(2);
		if len(piFooterCrc) != 2: raise BSLException("Timeout piFooterCrc")
		rxChecksum = struct.unpack('<H',piFooterCrc)[0]
		if rxChecksum != checksum: 
			if self.retr and self.retrcnt < 10:
				self.retrcnt += 1
				sys.stderr.write("Bad CRC received, retransmitting (try %i of %i)\n" %(self.retrcnt,self.maxRetr))
				return self.comTxRx(self.cmd, self.bslCoreCmd, self.length)
			else:
				raise BSLException("Bad Crc received")
		self.retrcnt=0
		if ord(rxBslCoreCmd[0]) == self.BSL_CORE_RESP_DATA:
			return rxBslCoreCmd[1:]
		elif ord(rxBslCoreCmd[0])  == self.BSL_CORE_RESP_MSG:
			if DEBUG > 1: print self.BSL_CORE_MSG[ord(rxBslCoreCmd[1])]
		else: raise BSLException("UNKNOWN BSL CORE RESPONSE")
		


	def comTxRx(self, cmd, bslCoreCmd, length, norx=False):
		"""Sends the command cmd with the data given in dataOut to the
		microcontroller and expects either an acknowledge or a frame
		with result from the microcontroller.  The results are stored
		in dataIn (if not a NULL pointer is passed).
		In this routine all the necessary protocol stuff is handled.
		Returns zero if the function was successful."""
		if DEBUG > 1: sys.stderr.write("* comTxRx()\n")
		txFrame     = []
		errorMsg    = 0xff
		self.cmd = cmd
		self.bslCoreCmd = bslCoreCmd
		self.length = length


		#Transmitting part ----------------------------------------
		#Prepare UART PI Wrapper
		piHeader = struct.pack('<BH',self.BSL_PI_HEADER, length)
		crc32_func = crcmod.predefined.mkCrcFun('crc-ccitt-false')
		checksum = crc32_func(bslCoreCmd)

		piFooter = struct.pack('<H',checksum)
		txFrame = piHeader + bslCoreCmd + piFooter;

		self.serialport.flushInput()                #clear receiving queue
		#TODO: Check after each transmitted character,
		#TODO: if microcontroller did send a character (probably a NAK!).
		for c in txFrame:
			self.serialport.write(c)
			if DEBUG > 3: sys.stderr.write(" %02x" % ord(c))
			#if self.serialport.inWaiting(): break  #abort when BSL replies, probably NAK
		if DEBUG > 3: sys.stderr.write(" \n")

		#Receiving part -------------------------------------------
		errorMsg = self.serialport.read(1)
		if not errorMsg: raise BSLException("Timeout")
		if ord(errorMsg) != self.BSL_ERR_MSG_ACK:               #acknowledge/OK
			if ord(errorMsg) == self.BSL_ERR_MSG_CRC and self.retr and self.retrcnt < self.maxRetr:
				self.retrcnt += 1
				sys.stderr.write("CRC error, retransmitting (try %i of %i)\n" %(self.retrcnt,self.maxRetr))
				return self.comTxRx(cmd, bslCoreCmd, length, norx)
			else:
				raise BSLException(self.BSL_ERR_MSG[ord(errorMsg)])
		self.retrcnt = 0
		if DEBUG > 1: sys.stderr.write( "  comTxRx() transmit OK\n")
		if norx: return 0
		return self.comRxFrame()

	def bslTxRx(self, cmd, addr, length = 0, data = None, wait=0, norx = False):
		"""Transmits a command (cmd) with its parameters:
		start-address (addr), length (len) and additional
		data (blkout) to boot loader.
		wait specified if the bsl sync should be tried once or
		repeated, forever
		Parameters return by boot loader are passed via blkin.
		"""
		if DEBUG > 1: sys.stderr.write("* bslTxRx()\n")

		bslCoreCmd = struct.pack("<B", cmd)
		#Add necessary information data to frame
		if addr:
			#need a 24 bit address
			bslCoreCmd =  bslCoreCmd + struct.pack("<I", addr<<8)[1:] #http://docs.python.org/library/struct.html#struct-alignment

		if data: #Copy data out of blkout into frame
			bslCoreCmd = bslCoreCmd + data

		return self.comTxRx(cmd, bslCoreCmd, len(bslCoreCmd), norx)  #Send frame

	def SetDTR(self, level, invert):
		"""Controls DTR pin (0: GND; 1: VCC; unless inverted flag is set)"""
		if invert:
			self.serialport.setDTR(not level)
		else:
			self.serialport.setDTR(level)
		if self.slowmode:
			time.sleep(0.040)

	def SetRTS(self, level, invert):
		"""Controls RTS pin (0: GND; 1: VCC; unless inverted flag is set)"""
		if invert:
			self.serialport.setRTS(not level)
		else:
			self.serialport.setRTS(level)
		if self.slowmode:
			time.sleep(0.040)

	def SetRSTpin(self, level=1):
		"""Controls RST/NMI pin (0: GND; 1: VCC; unless inverted flag is set)"""
		if self.swapRSTTEST:
			self.SetRTS(level, self.invertRST)
		else:
			self.SetDTR(level, self.invertRST)

	def SetTESTpin(self, level=1):
		"""Controls TEST pin (inverted on board: 0: VCC; 1: GND; unless inverted flag is set)"""
		if self.swapRSTTEST:
			self.SetDTR(level, self.invertTEST)
		else:
			self.SetRTS(level, self.invertTEST)


	def bslReset(self, invokeBSL=0):
		"""
		Applies BSL entry sequence on RST/NMI and TEST/VPP pins
		Parameters:
			invokeBSL = 1: complete sequence
			invokeBSL = 0: only RST/NMI pin accessed
		"""

		if DEBUG > 1: sys.stderr.write("* bslReset(invokeBSL=%s)\n" % invokeBSL)
		self.SetRSTpin(0)       #RST  pin: GND
		if invokeBSL:
			self.SetTESTpin(1)  #TEST pin: GND
			self.SetTESTpin(0)  #TEST pin: Vcc
			self.SetTESTpin(1)  #TEST pin: GND
			self.SetTESTpin(0)  #TEST pin: Vcc
			self.SetRSTpin (1)  #RST  pin: Vcc
			self.SetTESTpin(1)  #TEST pin: GND
		else:
			self.SetRSTpin(1)   #RST  pin: Vcc
		time.sleep(0.020)       #give MSP430's oscillator time to stabilize
		self.serialport.flushInput()    #clear buffers


class Segment:
    """store a string with memory contents along with its startaddress"""
    def __init__(self, startaddress = 0, data=None):
        if data is None:
            self.data = ''
        else:
            self.data = data
        self.startaddress = startaddress

    def __getitem__(self, index):
        return self.data[index]

    def __len__(self):
        return len(self.data)

    def __repr__(self):
        return "Segment(startaddress = 0x%04x, data=%r)" % (self.startaddress, self.data)

class Memory:
    """represent memory contents. with functions to load files"""
    def __init__(self, filename=None):
        self.segments = []
        if filename:
            self.filename = filename
            self.loadFile(filename)

    def append(self, seg):
        self.segments.append(seg)

    def __getitem__(self, index):
        return self.segments[index]

    def __len__(self):
        return len(self.segments)

    def loadIHex(self, file):
        """load data from a (opened) file in Intel-HEX format"""
        segmentdata = []
        currentAddr = 0
        startAddr   = 0
        extendAddr  = 0
        lines = file.readlines()
        for l in lines:
            if l[0] != ':': raise BSLException("File Format Error\n")
            l = l.strip()       #fix CR-LF issues...
            length  = int(l[1:3],16)
            address = int(l[3:7],16) + extendAddr
            type    = int(l[7:9],16)
            check   = int(l[-2:],16)
            if type == 0x00:
                if currentAddr != address:
                    if segmentdata:
                        self.segments.append( Segment(startAddr, string.join(segmentdata,'')) )
                    startAddr = currentAddr = address
                    segmentdata = []
                for i in range(length):
                    segmentdata.append( chr(int(l[9+2*i:11+2*i],16)) )
                currentAddr = length + currentAddr
            elif type == 0x02:
                extendAddr = int(l[9:13],16) << 4
            elif type in (0x01, 0x03, 0x04, 0x05):
                pass
            else:
                sys.stderr.write("Ignored unknown field (type 0x%02x) in ihex file.\n" % type)
        if segmentdata:
            self.segments.append( Segment(startAddr, string.join(segmentdata,'')) )

    def loadTIText(self, file):
        """load data from a (opened) file in TI-Text format"""
        next        = 1
        startAddr   = 0
        segmentdata = []
        #Convert data for MSP430, TXT-File is parsed line by line
        while next >= 1:
            #Read one line
            l = file.readline()
            if not l: break #EOF
            l = l.strip()
            if l[0] == 'q': break
            elif l[0] == '@':        #if @ => new address => send frame and set new addr.
                #create a new segment
                if segmentdata:
                    self.segments.append( Segment(startAddr, string.join(segmentdata,'')) )
                startAddr = int(l[1:],16)
                segmentdata = []
            else:
                for i in string.split(l):
                    segmentdata.append(chr(int(i,16)))
        if segmentdata:
            self.segments.append( Segment(startAddr, string.join(segmentdata,'')) )

    def loadELF(self, file):
        """load data from a (opened) file in ELF object format.
        File must be seekable"""
        import elf
        obj = elf.ELFObject()
        obj.fromFile(file)
        if obj.e_type != elf.ELFObject.ET_EXEC:
            raise Exception("No executable")
        for section in obj.getSections():
            if DEBUG:
                sys.stderr.write("ELF section %s at 0x%04x %d bytes\n" % (section.name, section.lma, len(section.data)))
            if len(section.data):
                self.segments.append( Segment(section.lma, section.data) )
        
    def loadFile(self, filename):
        """fill memory with the contents of a file. file type is determined from extension"""
        #TODO: do a contents based detection
        if filename[-4:].lower() == '.txt':
            self.loadTIText(open(filename, "rb"))
        elif filename[-4:].lower() in ('.a43', '.hex'):
            self.loadIHex(open(filename, "rb"))
        else:
            self.loadELF(open(filename, "rb"))

    def getMemrange(self, fromadr, toadr):
        """get a range of bytes from the memory. unavailable values are filled with 0xff."""
        res = ''
        toadr = toadr + 1   #python indxes are excluding end, so include it
        while fromadr < toadr:
            #print "fromto: %04x %04x" % (fromadr, toadr)
            for seg in self.segments:
                #print seg
                segend = seg.startaddress + len(seg.data)
                if seg.startaddress <= fromadr and fromadr < segend:
                    #print "startok 0x%04x %d" % (seg.startaddress, len(seg.data))
                    #print ("0x%04x "*3) % (segend, fromadr, toadr)
                    if toadr > segend:   #not all data in segment
                        #print "out of segment"
                        catchlength = segend-fromadr
                    else:
                        catchlength = toadr-fromadr
                    #print toadr-fromadr
                    #print catchlength
                    res = res + seg.data[fromadr-seg.startaddress : fromadr-seg.startaddress+catchlength]
                    fromadr = fromadr + catchlength    #adjust start
                    if len(res) >= toadr-fromadr:
                        break#return res
            else:
                    res = res + chr(255)
                    fromadr = fromadr + 1 #adjust start
                    #print "fill FF"
        #print "res: %r" % res
        return res


class BootStrapLoader(LowLevel):
    """higher level Bootstrap Loader functions."""

    ERR_VERIFY_FAILED       = "Error: verification failed"
    ERR_ERASE_CHECK_FAILED  = "Error: erase check failed"

    ACTION_PROGRAM          = 0x01 #Mask: program data
    ACTION_VERIFY           = 0x02 #Mask: verify data
    ACTION_ERASE_CHECK      = 0x04 #Mask: erase check

    #Max. bytes sent within one frame if parsing a TI TXT file.
    #( >= 16 and == n*16 and <= MAX_DATA_BYTES!)
    MAXDATA                 = 240-16


    def __init__(self, *args, **kargs):
        LowLevel.__init__(self, *args, **kargs)
        self.byteCtr        = 0
        self.meraseCycles   = 1
        self.patchRequired  = 0
        self.patchLoaded    = 0
        self.bslVer         = 0
        self.passwd         = None
        self.data           = None
        self.maxData        = self.MAXDATA
        self.cpu            = None



    def verifyBlk(self, addr, blkout, action):
        """verify memory against data or 0xff"""
        if DEBUG > 1: sys.stderr.write("* verifyBlk()\n")

        if action & self.ACTION_VERIFY or action & self.ACTION_ERASE_CHECK:
            if DEBUG: sys.stderr.write("  Check starting at 0x%04x, %d bytes ... \n" % (addr, len(blkout)))

            blkin = self.bslTxRx(self.BSL_RXBLK, addr, len(blkout))

            for i in range(len(blkout)):
                if action & self.ACTION_VERIFY:
                    #Compare data in blkout and blkin
                    if blkin[i] != blkout[i]:
                        sys.stderr.write("Verification failed at 0x%04x (0x%02x, 0x%02x)\n" % (addr+i, ord(blkin[i]), ord(blkout[i])))
                        sys.stderr.flush()
                        raise BSLException(self.ERR_VERIFY_FAILED)      #Verify failed!
                    continue
                elif action & self.ACTION_ERASE_CHECK:
                    #Compare data in blkin with erase pattern
                    if blkin[i] != chr(0xff):
                        sys.stderr.write("Erase Check failed at 0x%04x (0x%02x)\n" % (addr+i, ord(blkin[i])))
                        sys.stderr.flush()
                        raise BSLException(self.ERR_ERASE_CHECK_FAILED) #Erase Check failed!
                    continue

    def programBlk(self, addr, blkout, action):
        """programm a memory block"""
        if DEBUG > 1: sys.stderr.write("* programBlk()\n")

        #Check, if specified range is erased
        self.verifyBlk(addr, blkout, action & self.ACTION_ERASE_CHECK)

        if action & self.ACTION_PROGRAM:
            if DEBUG: sys.stderr.write("  Program starting at 0x%06x, %i bytes ...\n" % (addr, len(blkout)))
            #Program block
            self.bslTxRx(self.BSL_CMD_RXBLK, addr, len(blkout), blkout)

        #Verify block
        self.verifyBlk(addr, blkout, action & self.ACTION_VERIFY)

    #segments:
    #list of tuples or lists:
    #segements = [ (addr1, [d0,d1,d2,...]), (addr2, [e0,e1,e2,...])]
    def programData(self, segments, action):
        """programm or verify data"""
        if DEBUG > 1: sys.stderr.write("* programData()\n")
        for seg in segments:
            currentAddr = seg.startaddress
            pstart = 0
            while pstart<len(seg.data):
                length = self.MAXDATA
                if pstart+length > len(seg.data):
                    length = len(seg.data) - pstart
                self.programBlk(currentAddr, seg.data[pstart:pstart+length], action)
                pstart = pstart + length
                currentAddr = currentAddr + length
                self.byteCtr = self.byteCtr + length #total sum

    def uploadData(self, startaddress, size, wait=0):
        """upload a datablock"""
        if DEBUG > 1: sys.stderr.write("* uploadData()\n")
        data = ''
        pstart = 0
        while pstart<size:
            length = self.maxData
            if pstart+length > size:
                length = size - pstart
            data = data + self.bslTxRx(self.BSL_RXBLK,
                                       pstart+startaddress,
                                       length,
                                       wait=wait)[:-2] #cut away checksum
            pstart = pstart + length
        return data

    def txPasswd(self, passwd=None, wait=0):
        """transmit password, default if None is given."""
        if DEBUG > 1: sys.stderr.write("* txPassword(%r)\n" % passwd)
        if passwd is None:
            #Send "standard" password to get access to protected functions.
            sys.stderr.write("Transmit default password ...\n")
            sys.stderr.flush()
            #Flash is completely erased, the contents of all Flash cells is 0xff
            passwd = chr(0xff)*16
        else:
            #sanity check of password
            if len(passwd) != 16:
                raise ValueError, "password has wrong length (%d)\n" % len(passwd)
            sys.stderr.write('Transmit password ...\n')
            sys.stderr.flush()
        #send the password
        self.bslTxRx(self.BSL_CMD_RXPASSWORD,   #Command: Transmit Password
                       None,              		#Address of interupt vectors
                       0x0010,              	#Number of bytes
                       passwd,              	#password
                       wait=wait)           	#if wait is 1, try to sync forever


    #-----------------------------------------------------------------

    def actionMassErase(self):
        """Erase the flash memory completely (with mass erase command)"""
        sys.stderr.write("Mass Erase...\n")
        sys.stderr.flush()
	try:
		self.bslReset(1)                            #Invoke the boot loader.
		for i in range(self.meraseCycles):
		    if i == 1: sys.stderr.write("Additional Mass Erase Cycles...\n")
		    self.bslTxRx(self.BSL_CMD_MASSERASE,    #Command: Mass Erase
		                        None,             #Any address within flash memory.
		                        None)             #Required setting for mass erase!
		self.passwd = None                          #No password file required!
		#print "Mass Erase complete"
		#Transmit password to get access to protected BSL functions.
		self.txPasswd()
	except Exception, msg:
		if self.retr and self.erasecnt < self.maxErasecnt: #make sure we don't get in a loop with a broken node
			time.sleep(0.1)
			self.erasecnt += 1
			sys.stderr.write("Unexpected reply, retrying Mass Erase (try %i of %i)\n" %(self.erasecnt,self.maxErasecnt))
			self.actionMassErase()

    def actionStartBSL(self, usepatch=1, adjsp=1, replacementBSL=None, forceBSL=0, mayuseBSL=0, speed=None, bslreset=0):
        """start BSL, download patch if desired and needed, adjust SP if desired"""
        sys.stderr.write("Invoking BSL...\n")
        sys.stderr.flush()
        if bslreset:
            self.bslReset(1)                        #Invoke the boot loader.
        self.txPasswd(self.passwd)                  #transmit password

        #Read actual bootstrap loader version.
        #sys.stderr.write("Reading BSL version ...\n")
        rxBslVer = self.bslTxRx(self.BSL_CMD_TXBSLVERSION,        #Command: Read/Receive Block
                          None,                   #Start address
                          None)                       #No. of bytes to read
        bsl_ver_vendor, bsl_ver_ci, bsl_ver_api, bsl_ver_pi = struct.unpack(">4B", rxBslVer)
        sys.stderr.write("Current bootstrap loader version: vendor %x  CmdInterpret %x api %x pi %x)\n" % (bsl_ver_vendor, bsl_ver_ci, bsl_ver_api, bsl_ver_pi))
        sys.stderr.flush()

        #should the baudrate be changed?
        if speed is not None:
            self.actionChangeBaudrate(speed)            #change baudrate

    def actionDownloadBSL(self, bslsegments):
        sys.stderr.write("Load new BSL into RAM...\n")
        sys.stderr.flush()
        self.programData(bslsegments, self.ACTION_PROGRAM)
        sys.stderr.write("Verify new BSL...\n")
        sys.stderr.flush()
        self.programData(bslsegments, self.ACTION_VERIFY) #File to verify

        #Read startvector of bootstrap loader
        #blkin = self.bslTxRx(self.BSL_RXBLK, 0x0300, 2)
        #blkin = self.bslTxRx(self.BSL_RXBLK, 0x0220, 2)
        blkin = self.bslTxRx(self.BSL_RXBLK, bslsegments[0].startaddress, 2)
        startaddr = struct.unpack("<H", blkin[:2])[0]

        sys.stderr.write("Starting new BSL at 0x%04x...\n" % startaddr)
        sys.stderr.flush()
        self.bslTxRx(self.BSL_LOADPC,  #Command: Load PC
                     startaddr)        #Address to load into PC

        #BSL-Bugs should be fixed within "new" BSL
        self.BSLMemAccessWarning = 0
        self.patchRequired = 0
        self.patchLoaded   = 0

        #Re-send password to re-gain access to protected functions.
        self.txPasswd(self.passwd)

        #update version info
        #verison only valid for the internal ones, but it also makes sure 
        #that the patches are not applied if the user d/ls one
        self.bslVer = 0x0150

    def actionEraseCheck(self):
        """check the erasure of required flash cells."""
        sys.stderr.write("Erase Check by file ...\n")
        sys.stderr.flush()
        if self.data is not None:
            self.programData(self.data, self.ACTION_ERASE_CHECK)
        else:
            raise BSLException, "cannot do erase check against data with not knowing the actual data"

    def actionProgram(self):
        """program data into flash memory."""
        if self.data is not None:
            sys.stderr.write("Program ...\n")
            sys.stderr.flush()
            self.programData(self.data, self.ACTION_PROGRAM)
            sys.stderr.write("%i bytes programmed.\n" % self.byteCtr)
            sys.stderr.flush()
            speed = self.serialport.getBaudrate()
            if speed is not None and speed == 57600:
              sys.stderr.write("Jono just saved you %i seconds.\n" % (self.byteCtr*0.00092))
              sys.stderr.flush()
        else:
            raise BSLException, "programming without data not possible"

    def actionVerify(self):
        """Verify programmed data"""
        if self.data is not None:
            sys.stderr.write("Verify ...\n")
            sys.stderr.flush()
            self.programData(self.data, self.ACTION_VERIFY)
        else:
            raise BSLException, "verify without data not possible"

    def actionReset(self):
        """perform a reset, start user programm"""
        sys.stderr.write("Reset device ...\n")
        sys.stderr.flush()
        self.bslReset(0) #only reset

    def actionRun(self, address=0x220):
        """start program at specified address"""
        sys.stderr.write("Load PC with 0x%04x ...\n" % address)
        sys.stderr.flush()
        self.bslTxRx(self.BSL_LOADPC, #Command: Load PC
                            address)  #Address to load into PC

    def actionChangeBaudrate(self, baudrate=9600):
        """change baudrate. first the command is sent, then the comm
        port is reprogrammed. only possible with newer MSP430-BSL versions.
        (ROM >=1.6, downloadable >=1.5)"""
        try:
            baudconfigs = self.bauratetable[self.cpu]
        except KeyError:
            raise ValueError, "unknown CPU type %s, can't switch baudrate" % self.cpu
        try:
            b = baudconfigs[baudrate]
        except KeyError:
            raise ValueError, "baudrate not valid. valid values are %r" % baudconfigs.keys()
        
        sys.stderr.write("Changing baudrate to %d ...\n" % baudrate)
        sys.stderr.flush()
        self.bslTxRx(self.BSL_CMD_CHANGEBAUDRATE,   		#Command: change baudrate
                    None,None,struct.pack("<B", b),0,True)   	#True for norx -> don't wait for data back (there isn't any)
        time.sleep(0.010)                   			#recomended delay
        self.serialport.setBaudrate(baudrate)

    def actionReadBSLVersion(self):
        """informational output of BSL version number.
        (newer MSP430-BSLs only)"""
        ans = self.bslTxRx(self.BSL_TXVERSION, 0) #Command: receive version info
        #the following values are in big endian style!!!
        family_type, bsl_version = struct.unpack(">H8xH4x", ans[:-2]) #cut away checksum and extract data
        print "Device Type: 0x%04x\nBSL version: 0x%04x\n" % (family_type, bsl_version)


def usage():
    """print some help message"""
    sys.stderr.write("""
USAGE: %s [options] [file]
Version: %s

If "-" is specified as file the data is read from the stdinput.
A file ending with ".txt" is considered to be in TIText format,
'.a43' and '.hex' as IntelHex and all other filenames are
considered as ELF files.

General options:
  -h, --help            Show this help screen.
  -c, --comport=port    Specify the communication port to be used.
                        (Default is 0)
                                0->COM1 / ttyS0
                                1->COM2 / ttyS1
                                etc.
  -P, --password=file   Specify a file with the interrupt vectors that
                        are used as password. This can be any file that
                        has previously been used to program the device.
                        (e.g. -P INT_VECT.TXT).
  -f, --framesize=num   Max. number of data bytes within one transmitted
                        frame (16 to 240 in steps of 16) (e.g. -f 240).
  -m, --erasecycles=num Number of mass erase cycles (default is 1). Some
                        old F149 devices need additional erase cycles.
                        On newer devices it is no longer needed. (e.g. for
                        an old F149: -m20)
  -U, --unpatched       Do not download the BSL patch, even when it is
                        needed. This is used when a program is downloaded
                        into RAM and executed from there (and where flash
                        programming is not needed.)
  -D, --debug           Increase level of debug messages. This won't be
                        very useful for the average user...
  -I, --intelhex        Force fileformat to IntelHex
  -T, --titext          Force fileformat to be TIText
  -N, --notimeout       Don't use timeout on serial port (use with care)
  -B, --bsl=bsl.txt     Load and use new BSL from the TI Text file
  -S, --speed=baud      Reconfigure speed, only possible with newer
                        MSP403-BSL versions (>1.5, read slaa089a.pdf for
                        details). If the --bsl option is not used, an
                        internal BSL replacement will be loaded.
                        Needs a target with at least 2kB RAM!
                        Possible values are 9600, 19200, 38400, 57600, 115200
                        (default 9600)
  -R                    Enable retransmition on crc error
  -1, --f1x             Specify CPU family, in case autodetect fails
  -4, --f4x             Specify CPU family, in case autodetect fails
                        --F1x and --f2x are only needed when the "change
                        baudrate" feature is used and the autodetect feature
                        fails. If the device ID that is uploaded is known, it
                        has precedence to the command line option.
  -5, --f5x	            Specify CPU family, in case autodetect fails. Enables a 57600 baudrate
  --invert-reset        Invert signal on RST pin (used for some BSL hardware)
  --invert-test         Invert signal on TEST/TCK pin (used for some BSL
                        hardware)
  --swap-reset-test     Swap the RST and TEST pins (used for some BSL hardware)
  --telos-latch         Special twiddle in BSL reset for Telos hardware
  --telos-i2c           DTR/RTS map via an I2C switch to TCK/RST in Telos Rev.B
  --telos               Implies options --invert-reset, --invert-test, 
                        --swap-reset-test, and --telos-latch
  --telosb              Implies options --swap-reset-test, --telos-i2c,
                        --no-BSL-download, and --speed=38400
  --tmote               Identical operation to --telosb
  --no-BSL-download     Do not download replacement BSL (disable automatic)
  --force-BSL-download  Download replacement BSL even if not needed (the one
                        in the device would have the required features)
  --slow                Add delays when operating the conrol pins. Useful if
                        the pins/circuit has high capacitance.

Program Flow Specifiers:
  -e, --masserase       Mass Erase (clear all flash memory)
  -E, --erasecheck      Erase Check by file
  -p, --program         Program file
  -v, --verify          Verify by file

The order of the above options matters! The table is ordered by normal
execution order. For the options "Epv" a file must be specified.
Program flow specifiers default to "pvr" if a file is given.
Don't forget to specify "e" or "eE" when programming flash!

Data retreiving:
  -u, --upload=addr     Upload a datablock (see also: -s).
  -s, --size=num        Size of the data block do upload. (Default is 2)
  -x, --hex             Show a hexadecimal display of the uploaded data.
                        (Default)
  -b, --bin             Get binary uploaded data. This can be used
                        to redirect the output into a file.

Do before exit:
  -g, --go=address      Start programm execution at specified address.
                        This implies option --wait.
  -r, --reset           Reset connected MSP430. Starts application.
                        This is a normal device reset and will start
                        the programm that is specified in the reset
                        vector. (see also -g)
  -w, --wait            Wait for <ENTER> before closing serial port.

If it says "NAK received" it's probably because you specified no or a
wrong password.
""" % (sys.argv[0], VERSION))

#add some arguments to a function, but don't call it yet, instead return
#a wrapper object for later invocation
class curry:
    """create a callable with some arguments specified in advance"""
    def __init__(self, fun, *args, **kwargs):
        self.fun = fun
        self.pending = args[:]
        self.kwargs = kwargs.copy()

    def __call__(self, *args, **kwargs):
        if kwargs and self.kwargs:
            kw = self.kwargs.copy()
            kw.update(kwargs)
        else:
            kw = kwargs or self.kwargs
        return apply(self.fun, self.pending + args, kw)

    def __repr__(self):
        #first try if it a function
        try:
            return "curry(%s, %r, %r)" % (self.fun.func_name, self.pending, self.kwargs)
        except AttributeError:
            #fallback for callable classes
            return "curry(%s, %r, %r)" % (self.fun, self.pending, self.kwargs)

def hexify(line, bytes, width=16):
    return  '%04x  %s%s %s' % (
        line,
        ('%02x '*len(bytes)) % tuple(bytes),
        '   '* (width-len(bytes)),
        ('%c'*len(bytes)) % tuple(map(lambda x: (x>=32 and x<127) and x or ord('.'), bytes))
        )

#Main:
def main():
    global DEBUG
    import getopt
    filetype    = None
    filename    = None
    comPort     = 0     #Default setting.
    speed       = None
    unpatched   = 0
    reset       = 0
    wait        = 0     #wait at the end
    goaddr      = None
    bsl         = BootStrapLoader()
    toinit      = []
    todo        = []
    startaddr   = None
    size        = 2
    hexoutput   = 1
    notimeout   = 0
    bslrepl     = None
    mayuseBSL   = 1
    forceBSL    = 0

    sys.stderr.write("MSP430 Bootstrap Loader Version: %s  \n(c) Bart Jooris, Jono Vanhie-Van Gerwen UGENT-IBCN-IBBT based on tos-bsl 0.001 \n Modified to support f5x devices, now with retransmissions (-R)\n" % VERSION)

    try:
        opts, args = getopt.getopt(sys.argv[1:],
            "hc:P:wf:m:eEpvrg:UDudsxbITNRB:S:V145",
            ["help", "comport=", "password=", "wait", "framesize=",
             "erasecycles=", "masserase", "erasecheck", "program",
             "verify", "reset", "go=", "unpatched", "debug",
             "upload=", "download=", "size=", "hex", "bin", "retr"
             "intelhex", "titext", "notimeout", "bsl=", "speed=",
             "bslversion", "f1x", "f4x", "f5x", "invert-reset", "invert-test",
	     "swap-reset-test", "telos-latch", "telos-i2c", "telos", "telosb",
             "tmote","no-BSL-download", "force-BSL-download", "slow"]
        )
    except getopt.GetoptError:
        # print help information and exit:
        usage()
        sys.exit(2)

    for o, a in opts:
        if o in ("-h", "--help"):
            usage()
            sys.exit()
        elif o in ("-c", "--comport"):
            try:
                comPort = int(a)                    #try to convert decimal
            except ValueError:
                comPort = a                         #take the string and let serial driver decide
        elif o in ("-P", "--password"):
            #extract password from file
            bsl.passwd = Memory(a).getMemrange(0xffe0, 0xffff)
        elif o in ("-w", "--wait"):
            wait = 1
        elif o in ("-f", "--framesize"):
            try:
                maxData = int(a)                    #try to convert decimal
            except ValueError:
                sys.stderr.write("framesize must be a valid number\n")
                sys.exit(2)
            #Make sure that conditions for maxData are met:
            #( >= 16 and == n*16 and <= MAX_DATA_BYTES!)
            if maxData > BootStrapLoader.MAX_DATA_BYTES:
                maxData = BootStrapLoader.MAX_DATA_BYTES
            elif maxData < 16:
                maxData = 16
            bsl.maxData = maxData - (maxData % 16)
            sys.stderr.write( "Max. number of data bytes within one frame set to %i.\n" % maxData)
        elif o in ("-m", "--erasecycles"):
            try:
                meraseCycles = int(a)               #try to convert decimal
            except ValueError:
                sys.stderr.write("erasecycles must be a valid number\n")
                sys.exit(2)
            #sanity check of value
            if meraseCycles < 1:
                sys.stderr.write("erasecycles must be a positive number\n")
                sys.exit(2)
            if meraseCycles > 20:
                sys.stderr.write("warning: erasecycles set to a large number (>20): %d\n" % meraseCycles)
            sys.stderr.write( "Number of mass erase cycles set to %i.\n" % meraseCycles)
            bsl.meraseCycles = meraseCycles
        elif o in ("-e", "--masserase"):
            toinit.append(bsl.actionMassErase)        #Erase Flash
        elif o in ("-E", "--erasecheck"):
            toinit.append(bsl.actionEraseCheck)       #Erase Check (by file)
        elif o in ("-p", "--programm"):
            todo.append(bsl.actionProgram)          #Program file
        elif o in ("-v", "--verify"):
            todo.append(bsl.actionVerify)           #Verify file
        elif o in ("-r", "--reset"):
            reset = 1
        elif o in ("-g", "--go"):
            try:
                goaddr = int(a)                    #try to convert decimal
            except ValueError:
                try:
                    goaddr = int(a[2:],16)         #try to convert hex
                except ValueError:
                    sys.stderr.write("go address must be a valid number\n")
                    sys.exit(2)
            wait = 1
        elif o in ("-U", "--unpatched"):
            unpatched = 1
        elif o in ("-D", "--debug"):
            DEBUG = DEBUG + 1
        elif o in ("-u", "--upload"):
            try:
                startaddr = int(a)                  #try to convert decimal
            except ValueError:
                try:
                    startaddr = int(a,16)           #try to convert hex
                except ValueError:
                    sys.stderr.write("upload address must be a valid number\n")
                    sys.exit(2)
        elif o in ("-s", "--size"):
            try:
                size = int(a)
            except ValueError:
                try:
                    size = int(a,16)
                except ValueError:
                    sys.stderr.write("size must be a valid number\n")
                    sys.exit(2)
        elif o in ("-x", "--hex"):
            hexoutput = 1
        elif o in ("-b", "--bin"):
            hexoutput = 0
        elif o in ("-I", "--intelhex"):
            filetype = 0
        elif o in ("-T", "--titext"):
            filetype = 1
        elif o in ("-N", "--notimeout"):
            notimeout = 1
        elif o in ("-B", "--bsl"):
            bslrepl = Memory() #File to program
            bslrepl.loadFile(a)
        elif o in ("-V", "--bslversion"):
            todo.append(bsl.actionReadBSLVersion) #load replacement BSL as first item
        elif o in ("-S", "--speed"):
            try:
                speed = int(a)                    #try to convert decimal
            except ValueError:
                sys.stderr.write("speed must be decimal number\n")
                sys.exit(2)
        elif o in ("-1", "--f1x"):
            bsl.cpu = F1x
        elif o in ("-4", "--f4x"):
            bsl.cpu = F4x
        elif o in ("-5", "--f5x"):
            bsl.cpu = F5x
            bsl.swapRSTTEST = 1
            bsl.invertRST = 1
            speed = 57600
        elif o in ("-R"):
            bsl.retr = 1
        elif o in ("--invert-reset", ):
            bsl.invertRST = 1
        elif o in ("--invert-test", ):
            bsl.invertTEST = 1
        elif o in ("--swap-reset-test", ):
            bsl.swapRSTTEST = 1
        elif o in ("--telos-latch", ):
            bsl.telosLatch = 1
        elif o in ("--telos-i2c", ):
            bsl.telosI2C = 1
        elif o in ("--telos", ):
            bsl.invertRST = 1
            bsl.invertTEST = 1
            bsl.swapRSTTEST = 1
            bsl.telosLatch = 1
        elif o in ("--telosb", ):
            bsl.swapRSTTEST = 1
            bsl.telosI2C = 1
            mayuseBSL = 0
	    speed = 38400
        elif o in ("--tmote", ):
            bsl.swapRSTTEST = 1
            bsl.telosI2C = 1
            mayuseBSL = 0
	    speed = 38400
        elif o in ("--no-BSL-download", ):
            mayuseBSL = 0
        elif o in ("--force-BSL-download", ):
            forceBSL = 1
        elif o in ("--slow", ):
            bsl.slowmode = 1

    if len(args) == 0:
        sys.stderr.write("Use -h for help\n")
    elif len(args) == 1:                            #a filename is given
        if not todo:                                #if there are no actions yet
            todo.extend([                           #add some useful actions...
                bsl.actionProgram,
                bsl.actionVerify,
            ])
        filename = args[0]
    else:                                           #number of args is wrong
        usage()
        sys.exit(2)

    if DEBUG:   #debug infos
        sys.stderr.write("Debug level set to %d\n" % DEBUG)
        sys.stderr.write("Python version: %s\n" % sys.version)

    #sanity check of options
    if notimeout and goaddr is not None and startaddr is not None:
        sys.stderr.write("Option --notimeout can not be used together with both --upload and --go\n")
        sys.exit(1)

    if notimeout:
        sys.stderr.write("Warning: option --notimeout can cause improper function in some cases!\n")
        bsl.timeout = 0

    if goaddr and reset:
        sys.stderr.write("Warning: option --reset ignored as --go is specified!\n")
        reset = 0

    if startaddr and reset:
        sys.stderr.write("Warning: option --reset ignored as --upload is specified!\n")
        reset = 0

    sys.stderr.flush()
    
    #prepare data to download
    bsl.data = Memory()                             #prepare downloaded data
    if filetype is not None:                        #if the filetype is given...
        if filename is None:
            raise ValueError("no filename but filetype specified")
        if filename == '-':                         #get data from stdin
            file = sys.stdin
        else:
            file = open(filename, "rb")             #or from a file
        if filetype == 0:                           #select load function
            bsl.data.loadIHex(file)                 #intel hex
        elif filetype == 1:
            bsl.data.loadTIText(file)               #TI's format
        else:
            raise ValueError("illegal filetype specified")
    else:                                           #no filetype given...
        if filename == '-':                         #for stdin:
            bsl.data.loadIHex(sys.stdin)            #assume intel hex
        elif filename:
            bsl.data.loadFile(filename)             #autodetect otherwise

    if DEBUG > 3: sys.stderr.write("File: %r" % filename)

    bsl.comInit(comPort)                            #init port
    bsl.serialport.setBaudrate(9600)                #reset baudrate to default

    #initialization list
    if toinit:  #erase and erase check
        if DEBUG: sys.stderr.write("Preparing device ...\n")
        #bsl.actionStartBSL(usepatch=0, adjsp=0)     #no workarounds needed
        #if speed: bsl.actionChangeBaudrate(speed)   #change baud rate as fast as possible
        for f in toinit: f()

    if todo or goaddr or startaddr:
        if DEBUG: sys.stderr.write("Actions ...\n")
        #connect to the BSL
        bsl.actionStartBSL(
            usepatch=not unpatched,
            replacementBSL=bslrepl,
            forceBSL=forceBSL,
            mayuseBSL=mayuseBSL,
            speed=speed,
        )

    #work list
    if todo:
        if DEBUG > 0:       #debug
            #show a nice list of sheduled actions
            sys.stderr.write("TODO list:\n")
            for f in todo:
                try:
                    sys.stderr.write("   %s\n" % f.func_name)
                except AttributeError:
                    sys.stderr.write("   %r\n" % f)
        for f in todo: f()                          #work through todo list

    if reset:                                       #reset device first if desired
        bsl.actionReset()

    if goaddr is not None:                          #start user programm at specified address
        bsl.actionRun(goaddr)                       #load PC and execute

    #upload datablock and output
    if startaddr is not None:
        if goaddr:                                  #if a program was started...
            #don't restart BSL but wait for the device to enter it itself
            sys.stderr.write("Waiting for device to reconnect for upload: ")
            sys.stderr.flush()
            bsl.txPasswd(bsl.passwd, wait=1)        #synchronize, try forever...
            data = bsl.uploadData(startaddr, size)  #upload data
        else:
            data = bsl.uploadData(startaddr, size)  #upload data
        if hexoutput:                               #depending on output format
            m = 0
            while m < len(data):                    #print a hex display
                print hexify(startaddr+m, map(ord,data[m:m+16]))
                m = m + 16
        else:
            sys.stdout.write(data)                  #binary output w/o newline!
        wait = 0    #wait makes no sense as after the upload the device is still in BSL

    if wait:                                        #wait at the end if desired
        sys.stderr.write("Press <ENTER> ...\n")     #display a prompt
        sys.stderr.flush()
        raw_input()                                 #wait for newline

    bsl.comDone()           #Release serial communication port

if __name__ == '__main__':
    try:
        main()
    except SystemExit:
        raise               #let pass exit() calls
    except KeyboardInterrupt:
        if DEBUG: raise     #show full trace in debug mode
        sys.stderr.write("user abort.\n")   #short messy in user mode
        sys.exit(1)         #set errorlevel for script usage
    except Exception, msg:  #every Exception is caught and displayed
        if DEBUG: raise     #show full trace in debug mode
        sys.stderr.write("\nAn error occurred:\n%s\n" % msg) #short messy in user mode
        sys.exit(1)         #set errorlevel for script usage
